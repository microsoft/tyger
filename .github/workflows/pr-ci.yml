name: Tyger

on:
  push:
    branches: [main]
    tags: ["v*.*.*"]
  pull_request: # all branches
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AZURE_CLIENT_ID: 789b8572-1fae-4a5f-b376-6d9d14651245
  AZURE_TENANT_ID: 72f988bf-86f1-41af-91ab-2d7cd011db47
  AZURE_SUBSCRIPTION_ID: 87d8acb3-5176-4651-b457-6ab9cefd8e3d

  CAN_ACCESS_SECRETS: ${{ secrets.CAN_ACCESS_SECRETS }}

jobs:

  # If this is running a Dependabot PR or PR from a fork, it we won't have access to secrets
  # nor will be be able to obtain a federated token to access Azure resources.
  # Therefore, in those cases, we use hosted runners with managed identity to access Azure resources.
  # We only want to use those when necessary since they are a lot slower to come up, so this job
  # determines what we should pass in to `runs-on` for jobs that access Azure resources.
  # Also, this repo is configured to require approvals for all workflowd external contributors, and we
  # should inspect the code in the PR before approving the run.
  test-azure-needs-hosted-runner:
    runs-on: ubuntu-latest
    outputs:
      AZURE_RUNS_ON_JSON: ${{ steps.set-vars.outputs.AZURE_RUNS_ON_JSON }}
      AZURE_RUNS_ON_WINDOWS_JSON: ${{ steps.set-vars.outputs.AZURE_RUNS_ON_WINDOWS_JSON }}
    steps:
      - id: set-vars
        run: |
          if [[ -n "${CAN_ACCESS_SECRETS:-}" ]]; then
            AZURE_RUNS_ON_JSON='"ubuntu-latest"'
            AZURE_RUNS_ON_WINDOWS_JSON='"windows-latest"'
          else
            AZURE_RUNS_ON_JSON='["self-hosted", "1ES.Pool=tyger-gh-1es"]'
            AZURE_RUNS_ON_WINDOWS_JSON='["self-hosted", "1ES.Pool=tyger-gh-1es-windows"]'
          fi

          echo "AZURE_RUNS_ON_JSON=$AZURE_RUNS_ON_JSON" >> "$GITHUB_OUTPUT"
          echo "AZURE_RUNS_ON_WINDOWS_JSON=$AZURE_RUNS_ON_WINDOWS_JSON" >> "$GITHUB_OUTPUT"

  unit-tests-and-format:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    env:
      TYGER_MIN_NODE_COUNT: "1"
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - uses: actions/setup-go@v4
        with:
          go-version-file: cli/go.mod
          cache-dependency-path: cli/go.sum

      - run: |
          which dotnet
          dotnet --version
          dotnet --list-sdks
          dotnet --list-runtimes

      - uses: actions/setup-dotnet@v3
        with:
          global-json-file: server/global.json

      - run: |
          which dotnet
          dotnet --version
          dotnet --list-sdks
          dotnet --list-runtimes

      - name: Build and Verify format
        run: |
          set -euo pipefail
          make restore
          make verify-format
          make install-cli

      - run: |
          which dotnet
          dotnet --version
          dotnet --list-sdks
          dotnet --list-runtimes

      - name: Run unit tests
        run: |
          set -euo pipefail
          make unit-test

      - name: Generate NOTICE.txt
        run: |
          set -euo pipefail

          scripts/generate-notice.sh
          if [[ `git status --porcelain` ]]; then
            git diff
            echo "ERROR: NOTICE.txt needs to be regenerated using scripts/generate-notice.sh"
            exit 1
          fi

      - name: Check copyright headers
        run: |
          set -euo pipefail

          scripts/add-copyright-headers.sh
          if [[ `git status --porcelain` ]]; then
            git diff
            echo "ERROR: update copyright headers using scripts/add-cpopyright-headers.sh"
            exit 1
          fi

      - name: Build docs
        run: |
          set -euo pipefail
          cd docs
          npm install
          npm run docs:build
